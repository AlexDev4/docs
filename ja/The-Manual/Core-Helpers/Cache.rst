キャッシュ
##########

キャッシュヘルパーはレイアウトやビューをキャッシュするのを助けてくれ、繰り返しデータを取得する際に時間を節約できます。Cake
のビューキャッシングは一時的に解析したレイアウトやビューを選択したストレージエンジンに保存します。キャッシュヘルパーは他のヘルパーとはかなり異なった動作をすることに注意してください。直接呼び出せるメソッドはありません。代わりにビューはキャッシュタグでマーキングされ、コンテンツのブロックがキャッシュされていることを示します。

URL がリクエストされると、Cake
はそのリクエストされた文字列がすでにキャッシュされているかどうかを確認します。もしキャッシュされてれば、ディスパッチプロセスの
URL
の残りをスキップします。キャッシュされていないブロックは通常通り処理され、ビューは動作します。このおかげでキャッシュされた
URL
への各リクエストは最小限のコードだけが実行されるので実行時間を大きく節約できます。Cake
がキャッシュされたビューを見つけられない場合、あるいはキャッシュがリクエストされた
URL の期限を過ぎている場合、通常通りリクエストを処理し続けます。

一般的なキャッシュ
==================

キャッシュはサーバの負荷を減らすために一時的に保存するということを意図しています。たとえば、時間のかかるデータベースクエリの結果を保存し、ページを読み込む毎に実行する必要はないとします。

覚えておいてほしいのは、キャッシュは永続的なストレージではないということです。決して永続的な保存に使用しないでください。必要なときに再再生できるものだけをキャッシュします。

Cake のキャッシュエンジン
=========================

1.2
では新しくいくつかのキャッシュエンジンやキャッシュバックエンドがあります。キャッシュヘルパーと透過的なこれらのインターフェイスを使用すると、メディアについて特に心配せずにビューキャッシュを保存することができます。キャッシュエンジンは
app/config/core.php
設定ファイルを通して選択します。各キャッシュエンジン用のオプションは、core.php
設定ファイル内にリストされています。各キャッシュエンジンの詳細はキャッシングの章にあります。

File

ファイルエンジンは、cake
で使用されるデフォルトのキャッシュングエンジンです。ファイルシステムの通常ファイルに書き込みます。いくつかのオプションパラメータがありますが、デフォルトでも十分動作します。

APC

APC エンジンは `Alternative PHP Cache <https://www.php.net/manual/book.apcu>`_
オペコードキャッシュの実装です。XCache
と同様にこのエンジンはコンパイルされた PHP
オペコードをキャッシュします。

XCache

XCache キャッシングエンジンは、\ `XCache <https://xcache.lighttpd.net/>`_
オペコードキャッシングエンジンを実装している以外は機能的に APC
と同じです。適切に動作するにはユーザとパスワードが必要です。

Memcache

Memcache
エンジンはメモリキャッシュングサーバとして動作し、システムメモリ内にキャッシュオブジェクトを生成します。キャッシュングについての詳細は
`php.net <https://www.php.net/memcache>`_ や
`memcached <https://www.danga.com/memcached/>`_ にあります。

キャッシュヘルパーの設定
========================

ビューキャッシングやキャッシュヘルパーはいくつかの重要な設定要素があります。それらを以下に説明します。

ビューやコントローラでキャッシュヘルパーを使用するには、まず
``core.php`` の 80 行目の Configure::Cache.check を true
に設定しなければなりません。これが true
でない場合、キャッシュはチェックされず作成もされません。

コントローラでキャッシュする
============================

キャッシュ機能を使用するコントローラは $helpers 配列で CacheHelper
を読み込む必要があります。

::

    var $helpers = array('Cache');

アクションがキャッシュを必要としていることやどのくらいの間各アクションがキャッシュされるかを示す必要があります。コントローラの
$cacheAction 変数で指定します。$cacheAction
は配列を設定し、キャッシュさせるアクションやビューにキャッシュさせたい期間を秒単位で指定します。時間の値は
strtotime() 形式で表現できます。（たとえば、"1 hour" や "3 minutes"）

ArticlesController
の例を使用します。多くのトラフィックを受けるのでキャシュが必要です。

キャッシュは異なる時間間隔で Articles を見ます。

::

    var $cacheAction = array(
        'view/23/' => 21600,
        'view/48/' => 36000,
        'view/52'  => 48000
    );

このような articles の広い範囲の場合、全アクションをキャッシュします。

::

    var $cacheAction = array(
        'archives/' => '60000'
    );

コントローラに渡るキャッシュ時間を表示するために strtotime()
形式の時間を使用してコントローラのアクション毎にキャッシュします。

::

    var $cacheAction = "1 hour";

ビューでキャッシュされない内容をマークする
==========================================

場合によっては、\ *完全に*\ ビューをキャッシュしたくないことがあります。たとえば、ユーザがログインしていようがゲストとしてサイトを閲覧していようが、ページの一部を確実に異なる表示にしたい場合です。

キャッシュ *されない*
コンテンツのブロックを表示するためには、その部分を次のように
``<cake:nocache> </cake:nocache>`` で囲みます:

::

    <cake:nocache>
    <?php if ($session->check('User.name')) : ?>
        Welcome, <?php echo $session->read('User.name')?>.
    <?php else: ?>
        <?php echo $html->link('Login', 'users/login')?>
    <?php endif; ?>
    </cake:nocache>

その他のページのキャッシングのポイントとして、一度アクションがキャッシュされると、そのアクションのコントローラは呼び出されない、ということに注意してください。したがって、コントローラで
*null* に設定される変数を、\ ``<cake:nocache> </cake:nocache>``
の中に入れることはできません。

キャッシュをクリアする
======================

キャッシュされたビューで使用されたモデルが変更されると、Cake
はキャッシュされたビューをクリアすることを覚えておくのは重要です。たとえば、キャッシュされたビューが
Post モデルから取得したデータを使用していて、Post で INSERT, UPDATE,
DELETE
クエリーが生成されると、そのビューのキャッシュはクリアされ新しいコンテンツが次のリクエストの際に生成されます。

手動でキャッシュをクリアする必要がある場合、Cache::clear()
を呼び出すことでできます。これはビューでないデータを含むキャッシュされたデータ
**すべて** をクリアします。
